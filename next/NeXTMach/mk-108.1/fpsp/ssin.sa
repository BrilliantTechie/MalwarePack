*
*	ssin.sa 1.8 10/11/90
*
*	The entry point sSIN computes the sine of an input argument
*	sCOS computes the cosine, and sSINCOS computes both. The
*	corresponding entry points with a "d" computes the same
*	corresponding function values for denormalized inputs.
*
*	Input: Double-extended number X in location pointed to
*		by address register a0.
*
*	Output: The funtion value sin(X) or cos(X) returned in Fp0 if SIN or
*		COS is requested. Otherwise, for SINCOS, sin(X) is returned
*		in Fp0, and cos(X) is returned in Fp1.
*
*	Modifies: Fp0 for SIN or COS; both Fp0 and Fp1 for SINCOS.
*
*	Accuracy and Monotonicity: The returned result is within 1 ulp in
*		64 significant bit, i.e. within 0.5001 ulp to 53 bits if the
*		result is subsequently rounded to double precision. The
*		result is provably monotonic in double precision.
*
*	Speed: The programs sSIN and sCOS take approximately 150 cycles for
*		input argument X such that |X| < 15Pi, which is the the usual
*		situation. The speed for sSINCOS is approximately 190 cycles.
*
*	Algorithm:
*
*	SIN and COS:
*	1. If SIN is invoked, set AdjN := 0; otherwise, set AdjN := 1.
*
*	2. If |X| >= 15Pi or |X| < 2**(-40), go to 7.
*
*	3. Decompose X as X = N(Pi/2) + r where |r| <= Pi/4. Let
*		k = N mod 4, so in particular, k = 0,1,2,or 3. Overwirte
*		k by k := k + AdjN.
*
*	4. If k is even, go to 6.
*
*	5. (k is odd) Set j := (k-1)/2, sgn := (-1)**j. Return sgn*cos(r)
*		where cos(r) is approximated by an even polynomial in r,
*		1 + r*r*(B1+s*(B2+ ... + s*B8)),	s = r*r.
*		Exit.
*
*	6. (k is even) Set j := k/2, sgn := (-1)**j. Return sgn*sin(r)
*		where sin(r) is approximated by an odd polynomial in r
*		r + r*s*(A1+s*(A2+ ... + s*A7)),	s = r*r.
*		Exit.
*
*	7. If |X| > 1, go to 9.
*
*	8. (|X|<2**(-40)) If SIN is invoked, return X; otherwise return 1.
*
*	9. Overwrite X by X := X rem 2Pi. Now that |X| <= Pi, go back to 3.
*
*	SINCOS:
*	1. If |X| >= 15Pi or |X| < 2**(-40), go to 6.
*
*	2. Decompose X as X = N(Pi/2) + r where |r| <= Pi/4. Let
*		k = N mod 4, so in particular, k = 0,1,2,or 3.
*
*	3. If k is even, go to 5.
*
*	4. (k is odd) Set j1 := (k-1)/2, j2 := j1 (EOR) (k mod 2), i.e.
*		j1 exclusive or with the l.s.b. of k.
*		sgn1 := (-1)**j1, sgn2 := (-1)**j2.
*		SIN(X) = sgn1 * cos(r) and COS(X) = sgn2*sin(r) where
*		sin(r) and cos(r) are computed as odd and even polynomials
*		in r, respectively. Exit
*
*	5. (k is even) Set j1 := k/2, sgn1 := (-1)**j1.
*		SIN(X) = sgn1 * sin(r) and COS(X) = sgn1*cos(r) where
*		sin(r) and cos(r) are computed as odd and even polynomials
*		in r, respectively. Exit
*
*	6. If |X| > 1, go to 8.
*
*	7. (|X|<2**(-40)) SIN(X) = X and COS(X) = 1. Exit.
*
*	8. Overwrite X by X := X rem 2Pi. Now that |X| <= Pi, go back to 2.
*

*		Copyright (C) Motorola, Inc. 1990
*			All Rights Reserved
*
*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MOTOROLA 
*	The copyright notice above does not evidence any  
*	actual or intended publication of such source code.

SSIN	IDNT	2,1 Motorola 040 Floating Point Software Package

	section	15

ADJN	DC.L $00000000
POSNEG1	DC.L $3F800000

X	DC.W $0000
XDCARE	DC.W $0000
XFRAC	DC.L $00000000,$00000000
N	DC.L $00000000

BOUNDS1	DC.L $3FD78000,$4004BC7E
TWOBYPI	DC.L $3FE45F30,$6DC9C883

RPRIME	DC.L $00000000,$00000000,$00000000,$00000000
SPRIME	DC.L $00000000,$00000000,$00000000,$00000000

SINA7	DC.L $BD6AAA77,$CCC994F5
SINA6	DC.L $3DE61209,$7AAE8DA1

SINA5	DC.L $BE5AE645,$2A118AE4
SINA4	DC.L $3EC71DE3,$A5341531

SINA3	DC.L $BF2A01A0,$1A018B59,$00000000,$00000000

SINA2	DC.L $3FF80000,$88888888,$888859AF,$00000000

SINA1	DC.L $BFFC0000,$AAAAAAAA,$AAAAAA99,$00000000

COSB8	DC.L $3D2AC4D0,$D6011EE3
COSB7	DC.L $BDA9396F,$9F45AC19

COSB6	DC.L $3E21EED9,$0612C972
COSB5	DC.L $BE927E4F,$B79D9FCF

COSB4	DC.L $3EFA01A0,$1A01D423,$00000000,$00000000

COSB3	DC.L $BFF50000,$B60B60B6,$0B61D438,$00000000

COSB2	DC.L $3FFA0000,$AAAAAAAA,$AAAAAB5E
COSB1	DC.L $BF000000

INARG	DC.L $00000000,$00000000,$00000000
ENDFLAG	DC.L $00000000

INVTWOPI DC.L $3FFC0000,$A2F9836E,$4E44152A
TWOTO63	DC.L $5F000000

TWOPI1	DC.L $40010000,$C90FDAA2,$00000000,$00000000
TWOPI2	DC.L $3FDF0000,$85A308D4,$00000000,$00000000

*--N*PI/2, -32 <= N <= 32, IN A LEADING TERM IN EXT. AND TRAILING
*--TERM IN SGL. NOTE THAT PI IS 64-BIT LONG, THUS N*PI/2 IS AT
*--MOST 69 BITS LONG.
NPIBY2:
	DC.L	$C0040000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0040000,$C2C75BCD,$105D7C23,$A1B00000
	DC.L	$C0040000,$BC7EDCF7,$FF523612,$21A00000
	DC.L	$C0040000,$B6365E22,$EE46F000,$A0000000
	DC.L	$C0040000,$AFEDDF4D,$DD3BA9EE,$A1C00000
	DC.L	$C0040000,$A9A56078,$CC3063DD,$21900000
	DC.L	$C0040000,$A35CE1A3,$BB251DCB,$A0800000
	DC.L	$C0040000,$9D1462CE,$AA19D7B9,$A1D00000
	DC.L	$C0040000,$96CBE3F9,$990E91A8,$21800000
	DC.L	$C0040000,$90836524,$88034B96,$A0C00000
	DC.L	$C0040000,$8A3AE64F,$76F80584,$A1E00000
	DC.L	$C0040000,$83F2677A,$65ECBF73,$21600000
	DC.L	$C0030000,$FB53D14A,$A9C2F2C2,$A1000000
	DC.L	$C0030000,$EEC2D3A0,$87AC669F,$20000000
	DC.L	$C0030000,$E231D5F6,$6595DA7C,$21400000
	DC.L	$C0030000,$D5A0D84C,$437F4E58,$A1200000
	DC.L	$C0030000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0030000,$BC7EDCF7,$FF523612,$21200000
	DC.L	$C0030000,$AFEDDF4D,$DD3BA9EE,$A1400000
	DC.L	$C0030000,$A35CE1A3,$BB251DCB,$A0000000
	DC.L	$C0030000,$96CBE3F9,$990E91A8,$21000000
	DC.L	$C0030000,$8A3AE64F,$76F80584,$A1600000
	DC.L	$C0020000,$FB53D14A,$A9C2F2C2,$A0800000
	DC.L	$C0020000,$E231D5F6,$6595DA7C,$20C00000
	DC.L	$C0020000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0020000,$AFEDDF4D,$DD3BA9EE,$A0C00000
	DC.L	$C0020000,$96CBE3F9,$990E91A8,$20800000
	DC.L	$C0010000,$FB53D14A,$A9C2F2C2,$A0000000
	DC.L	$C0010000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0010000,$96CBE3F9,$990E91A8,$20000000
	DC.L	$C0000000,$C90FDAA2,$2168C235,$00000000
	DC.L	$BFFF0000,$C90FDAA2,$2168C235,$00000000
	DC.L	$00000000,$00000000,$00000000,$00000000
	DC.L	$3FFF0000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40000000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40010000,$96CBE3F9,$990E91A8,$A0000000
	DC.L	$40010000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40010000,$FB53D14A,$A9C2F2C2,$20000000
	DC.L	$40020000,$96CBE3F9,$990E91A8,$A0800000
	DC.L	$40020000,$AFEDDF4D,$DD3BA9EE,$20C00000
	DC.L	$40020000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40020000,$E231D5F6,$6595DA7C,$A0C00000
	DC.L	$40020000,$FB53D14A,$A9C2F2C2,$20800000
	DC.L	$40030000,$8A3AE64F,$76F80584,$21600000
	DC.L	$40030000,$96CBE3F9,$990E91A8,$A1000000
	DC.L	$40030000,$A35CE1A3,$BB251DCB,$20000000
	DC.L	$40030000,$AFEDDF4D,$DD3BA9EE,$21400000
	DC.L	$40030000,$BC7EDCF7,$FF523612,$A1200000
	DC.L	$40030000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40030000,$D5A0D84C,$437F4E58,$21200000
	DC.L	$40030000,$E231D5F6,$6595DA7C,$A1400000
	DC.L	$40030000,$EEC2D3A0,$87AC669F,$A0000000
	DC.L	$40030000,$FB53D14A,$A9C2F2C2,$21000000
	DC.L	$40040000,$83F2677A,$65ECBF73,$A1600000
	DC.L	$40040000,$8A3AE64F,$76F80584,$21E00000
	DC.L	$40040000,$90836524,$88034B96,$20C00000
	DC.L	$40040000,$96CBE3F9,$990E91A8,$A1800000
	DC.L	$40040000,$9D1462CE,$AA19D7B9,$21D00000
	DC.L	$40040000,$A35CE1A3,$BB251DCB,$20800000
	DC.L	$40040000,$A9A56078,$CC3063DD,$A1900000
	DC.L	$40040000,$AFEDDF4D,$DD3BA9EE,$21C00000
	DC.L	$40040000,$B6365E22,$EE46F000,$20000000
	DC.L	$40040000,$BC7EDCF7,$FF523612,$A1A00000
	DC.L	$40040000,$C2C75BCD,$105D7C23,$21B00000
	DC.L	$40040000,$C90FDAA2,$2168C235,$00000000

	section	8

	include	fpsp.h

	xref	t_frcinx
	xref	t_extdnrm
	xref	sto_cos

	xdef	ssind
ssind:
*--SIN(X) = X FOR DENORMALIZED X
	bra		t_extdnrm

	xdef	scosd
scosd:
*--COS(X) = 1 FOR DENORMALIZED X

	FMOVE.S		#:3F800000,FP0
*
*	9D25B Fix: Sometimes the previous fmove.s sets fpsr bits
*
	fmove.l		#0,fpsr
*
	bra		t_frcinx

	xdef	ssin
ssin:
*--SET ADJN TO 0
	MOVE.L		#0,ADJN
	BRA.B		SINBGN

	xdef	scos
scos:
*--SET ADJN TO 1
	MOVE.L		#1,ADJN

SINBGN:
*--SAVE FPCR, FP1. CHECK IF |X| IS TOO SMALL OR LARGE
	FMOVE.L		FPCR,d1
	FMOVE.L		#0,FPCR

	FMOVE.X		(a0),FP0	...LOAD INPUT
	fmovem.x	fp1,-(a7)	...save fp1

	FMOVE.X		FP0,X
	MOVE.W		XFRAC,XDCARE	...COMPACTIFY X
	MOVE.L		X,D0
	ANDI.L		#$7FFFFFFF,D0
	CMP2.L		BOUNDS1,D0	...2**(-40) < |X| < 15 PI?
	BCS.W		SINBORS

SINMAIN:
*--THIS IS THE USUAL CASE, |X| <= 15 PI.
*--THE ARGUMENT REDUCTION IS DONE BY TABLE LOOK UP.
	FMOVE.X		FP0,FP1
	FMUL.D		TWOBYPI,FP1	...X*2/PI

*--HIDE THE NEXT THREE INSTRUCTIONS
	LEA		NPIBY2,A1 ...TABLE OF N*PI/2, N = -32,...,32
	ADDA.L		#$200,A1	...OFFSET BY 32 ENTRIES
	fmovem.x	fp2,-(a7) ...save fp2

*--FP1 IS NOW READY
	FMOVE.L		FP1,N		...CONVERT TO INTEGER

	MOVE.L		N,D0
	ASL.L		#4,D0
	ADDA.L		D0,A1	...A1 IS THE ADDRESS OF N*PIBY2
*				...WHICH IS IN TWO PIECES Y1 & Y2

	FSUB.X		(A1)+,FP0	...X-Y1
*--HIDE THE NEXT ONE
	fmovem.x	fp3,-(a7) ...save fp3
	FSUB.S		(A1),FP0	...FP0 IS R = (X-Y1)-Y2

*--GET N+ADJN AND SEE IF SIN(R) OR COS(R) IS NEEDED
	MOVE.L		N,D0
	ADD.L		ADJN,D0	...SEE IF D0 IS ODD OR EVEN
	ROR.L		#1,D0	...D0 WAS ODD IFF D0 IS NEGATIVE
	CMPI.L		#0,D0
	BLT.W		COSPOLY

SINPOLY:
*--LET J BE THE LEAST SIG. BIT OF D0, LET SGN := (-1)**J.
*--THEN WE RETURN	SGN*SIN(R). SGN*SIN(R) IS COMPUTED BY
*--R' + R'*S*(A1 + S(A2 + S(A3 + S(A4 + ... + SA7)))), WHERE
*--R' = SGN*R, S=R*R. THIS CAN BE REWRITTEN AS
*--R' + R'*S*( [A1+T(A3+T(A5+TA7))] + [S(A2+T(A4+TA6))])
*--WHERE T=S*S.
*--NOTE THAT A3 THROUGH A7 ARE STORED IN DOUBLE PRECISION
*--WHILE A1 AND A2 ARE IN DOUBLE-EXTENDED FORMAT.
	FMOVE.X		FP0,X	...X IS R
	FMUL.X		FP0,FP0	...FP0 IS S
*---HIDE THE NEXT TWO WHILE WAITING FOR FP0
	FMOVE.D		SINA7,FP3
	FMOVE.D		SINA6,FP2
*--FP0 IS NOW READY
	FMOVE.X		FP0,FP1
	FMUL.X		FP1,FP1	...FP1 IS T
*--HIDE THE NEXT TWO WHILE WAITING FOR FP1

	ROR.L		#1,D0
	ANDI.L		#$80000000,D0
*				...LEAST SIG. BIT OF D0 IN SIGN POSITION
	EOR.L		D0,X	...X IS NOW R'= SGN*R

	FMUL.X		FP1,FP3	...TA7
	FMUL.X		FP1,FP2	...TA6

	FADD.D		SINA5,FP3 ...A5+TA7
	FADD.D		SINA4,FP2 ...A4+TA6

	FMUL.X		FP1,FP3	...T(A5+TA7)
	FMUL.X		FP1,FP2	...T(A4+TA6)

	FADD.D		SINA3,FP3 ...A3+T(A5+TA7)
	FADD.X		SINA2,FP2 ...A2+T(A4+TA6)

	FMUL.X		FP3,FP1	...T(A3+T(A5+TA7))
*--FP3 RELEASED, RESTORE NOW AND TAKE SOME ADVANTAGE OF HIDING
	fmovem.x	(a7)+,fp3

	FMUL.X		FP0,FP2	...S(A2+T(A4+TA6))
	FADD.X		SINA1,FP1 ...A1+T(A3+T(A5+TA7))
	FMUL.X		X,FP0	...R'*S

	FADD.X		FP2,FP1	...[A1+T(A3+T(A5+TA7))]+[S(A2+T(A4+TA6))]
*--FP2 RELEASED, RESTORE NOW AND TAKE FULL ADVANTAGE OF HIDING
	fmovem.x	(a7)+,fp2

	FMUL.X		FP1,FP0		...SIN(R')-R'
*--FP1 RELEASED.
	fmovem.x	(a7)+,fp1

	FMOVE.L		d1,FPCR		;restore users exceptions
	FADD.X		X,FP0		;last inst - possible exception set
	bra		t_frcinx


COSPOLY:
*--LET J BE THE LEAST SIG. BIT OF D0, LET SGN := (-1)**J.
*--THEN WE RETURN	SGN*COS(R). SGN*COS(R) IS COMPUTED BY
*--SGN + S'*(B1 + S(B2 + S(B3 + S(B4 + ... + SB8)))), WHERE
*--S=R*R AND S'=SGN*S. THIS CAN BE REWRITTEN AS
*--SGN + S'*([B1+T(B3+T(B5+TB7))] + [S(B2+T(B4+T(B6+TB8)))])
*--WHERE T=S*S.
*--NOTE THAT B4 THROUGH B8 ARE STORED IN DOUBLE PRECISION
*--WHILE B2 AND B3 ARE IN DOUBLE-EXTENDED FORMAT, B1 IS -1/2
*--AND IS THEREFORE STORED AS SINGLE PRECISION.

	FMUL.X		FP0,FP0	...FP0 IS S
*---HIDE THE NEXT TWO WHILE WAITING FOR FP0
	FMOVE.D		COSB8,FP2
	FMOVE.D		COSB7,FP3
*--FP0 IS NOW READY
	FMOVE.X		FP0,FP1
	FMUL.X		FP1,FP1	...FP1 IS T
*--HIDE THE NEXT TWO WHILE WAITING FOR FP1
	FMOVE.X		FP0,X	...X IS S
	ROR.L		#1,D0
	ANDI.L		#$80000000,D0
*			...LEAST SIG. BIT OF D0 IN SIGN POSITION

	FMUL.X		FP1,FP2	...TB8
*--HIDE THE NEXT TWO WHILE WAITING FOR THE XU
	EOR.L		D0,X	...X IS NOW S'= SGN*S
	ANDI.L		#$80000000,D0

	FMUL.X		FP1,FP3	...TB7
*--HIDE THE NEXT TWO WHILE WAITING FOR THE XU
	ORI.L		#$3F800000,D0	...D0 IS SGN IN SINGLE
	MOVE.L		D0,POSNEG1

	FADD.D		COSB6,FP2 ...B6+TB8
	FADD.D		COSB5,FP3 ...B5+TB7

	FMUL.X		FP1,FP2	...T(B6+TB8)
	FMUL.X		FP1,FP3	...T(B5+TB7)

	FADD.D		COSB4,FP2 ...B4+T(B6+TB8)
	FADD.X		COSB3,FP3 ...B3+T(B5+TB7)

	FMUL.X		FP1,FP2	...T(B4+T(B6+TB8))
	FMUL.X		FP3,FP1	...T(B3+T(B5+TB7))
*--FP3 RELEASED, RESTORE NOW AND TAKE SOME ADVANTAGE OF HIDING
	fmovem.x	(a7)+,fp3

	FADD.X		COSB2,FP2 ...B2+T(B4+T(B6+TB8))
	FADD.S		COSB1,FP1 ...B1+T(B3+T(B5+TB7))

	FMUL.X		FP2,FP0	...S(B2+T(B4+T(B6+TB8)))
*--FP2 RELEASED.
	fmovem.x	(a7)+,fp2

	FADD.X		FP1,FP0
*--FP1 RELEASED
	fmovem.x	(a7)+,fp1

	FMUL.X		X,FP0

	FMOVE.L		d1,FPCR		;restore users exceptions
	FADD.S		POSNEG1,FP0	;last inst - possible exception set
	bra		t_frcinx


SINBORS:
*--IF |X| > 15PI, WE USE THE GENERAL ARGUMENT REDUCTION.
*--IF |X| < 2**(-40), RETURN X OR 1.
	CMPI.L		#$3FFF8000,D0
	BGT.B		REDUCEX

SINSM:
	MOVE.L		ADJN,D0
	CMPI.L		#0,D0
	BGT.B		COSTINY

SINTINY:
	fmovem.x	(a7)+,fp1
	MOVE.W		#$0000,XDCARE	...JUST IN CASE
	FMOVE.L		d1,FPCR		;restore users exceptions
	FMOVE.X		X,FP0		;last inst - possible exception set
	bra		t_frcinx


COSTINY:
	fmovem.x	(a7)+,fp1
	FMOVE.S		#:3F800000,FP0

	FMOVE.L		d1,FPCR		;restore users exceptions
	FSUB.S		#:00800000,FP0	;last inst - possible exception set
	bra		t_frcinx


REDUCEX:
*--WHEN REDUCEX IS USED, THE CODE WILL INEVITABLY BE SLOW.
*--THIS REDUCTION METHOD, HOWEVER, IS MUCH FASTER THAN USING
*--THE REMAINDER INSTRUCTION WHICH IS NOW IN SOFTWARE.

	fmovem.x	fp1,-(a7)
	fmovem.x	fp2,-(a7)
	MOVE.L		D2,-(A7)
*--ON ENTRY, FP0 IS X, ON RETURN, FP0 IS X REM 2PI, |X| <= PI.

LOOP:
	FMOVE.X		FP0,INARG	...+-2**K * F, 1 <= F < 2
	MOVE.W		INARG,D0
	ANDI.L		#$00007FFF,D0
	SUBI.L		#$00003FFF,D0	...D0 IS K
	CMPI.L		#28,D0
	BLE.B		LASTLOOP
CONTLOOP:
	SUBI.L		#28,D0	 ...D0 IS L := K-28
	MOVE.L		#0,ENDFLAG
	BRA.B		WORK
LASTLOOP:
	CLR.L		D0		...D0 IS L := 0
	MOVE.L		#1,ENDFLAG

WORK:
*--FIND THE REMAINDER OF X W.R.T.	2**L * 2PI. L IS SO CHOSEN
*--THAT	INT( X * 2PI / 2**(L) ) < 2**30.

*--CREATE 2**(-L) * INVTWOPI, SIGN(INARG)*2**(63),
*--2**L * TWOPI1, 2**L * TWOPI2

	MOVE.L		#$00003FFC,d2	...BIASED EXPO OF INVTWOPI
	SUB.L		D0,d2		...BIASED EXPO OF 2**(-L)*INVTWOPI
	MOVE.W		d2,INVTWOPI
	FMOVE.X		FP0,FP1
	FMUL.X		INVTWOPI,FP1
*--WE MUST NOW FIND INT(FP1). SINCE WE NEED THIS VALUE IN
*--FLOATING POINT FORMAT, THE TWO FMOVE'S	FMOVE.L FP <--> N
*--WILL BE TOO INEFFICIENT. THE WAY AROUND IT IS THAT
*--(SIGN(INARG)*2**63	+	FP1) - SIGN(INARG)*2**63 WILL GIVE
*--US THE DESIRED VALUE IN FLOATING POINT.

*--HIDE SIX CYCLES OF INSTRUCTION
	MOVE.L		INARG,d2
	ANDI.L		#$80000000,d2
	ORI.L		#$5F000000,d2	...d2 IS SIGN(INARG)*2**63 IN SGL
	MOVE.L		d2,TWOTO63

	MOVE.L		D0,d2
	ADDI.L		#$00004001,d2	...BIASED EXPO OF 2**L * TWOPI

*--FP1 IS READY
	FADD.S		TWOTO63,FP1	...THE FRACTIONAL PART OF FP1 IS ROUNDED

*--HIDE 4 CYCLES OF INSTRUCTION
	MOVE.W		d2,TWOPI1
	ADDI.L		#$00003FDF,D0
	MOVE.W		D0,TWOPI2
	MOVE.L		ENDFLAG,D0

*--FP1 IS READY
	FSUB.S		TWOTO63,FP1
*--HIDE THE NEXT INSTRUCTION
	FMOVE.X		TWOPI1,FP2
	FMUL.X		FP1,FP2	...M*Y1
	FMUL.X		TWOPI2,FP1	...M*Y2
	FSUB.X		FP2,FP0	...(X-MY1)
	FSUB.X		FP1,FP0	...(X-MY1)-MY2
*--FP0 IS X REM 2**L * 2PI
	CMPI.L		#0,D0
	BLE.W		LOOP

RESTORE:
	MOVE.L		(A7)+,d2
	fmovem.x	(a7)+,fp2
	fmovem.x	(a7)+,fp1

	MOVE.L		ADJN,D0
	CMPI.L		#4,D0
	BLT.W		SINMAIN
	BRA.B		SCMAIN

	xdef	ssincosd
ssincosd:
*--SIN AND COS OF X FOR DENORMALIZED X

	FMOVE.S		#:3F800000,FP1
	bsr		sto_cos		;store cosine result
	bra		t_extdnrm

	xdef	ssincos
ssincos:
*--SET ADJN TO 4
	MOVE.L		#4,ADJN

	FMOVE.L		FPCR,d1
	FMOVE.L		#0,FPCR

	FMOVE.X		(a0),FP0	...LOAD INPUT

	FMOVE.X		FP0,X
	MOVE.W		XFRAC,XDCARE	...COMPACTIFY X
	MOVE.L		X,D0
	ANDI.L		#$7FFFFFFF,D0
	CMP2.L		BOUNDS1,D0	...2**(-40) < |X| < 15 PI?
	BCS.W		SCBORS

SCMAIN:
*--THIS IS THE USUAL CASE, |X| <= 15 PI.
*--THE ARGUMENT REDUCTION IS DONE BY TABLE LOOK UP.
	FMOVE.X		FP0,FP1
	FMUL.D		TWOBYPI,FP1	...X*2/PI

*--HIDE THE NEXT THREE INSTRUCTIONS
	LEA		NPIBY2,A1 ...TABLE OF N*PI/2, N = -32,...,32
	ADDA.L		#$200,A1	...OFFSET BY 32 ENTRIES
	fmovem.x	 fp2,-(a7) ...save fp2

*--FP1 IS NOW READY
	FMOVE.L		FP1,N		...CONVERT TO INTEGER

	MOVE.L		N,D0
	ASL.L		#4,D0
	ADDA.L		D0,A1		...ADDRESS OF N*PIBY2, IN Y1, Y2

	FSUB.X		(A1)+,FP0	...X-Y1

*--HIDE THE NEXT TWO
	MOVE.L		N,D0
	ROR.L		#1,D0

	FSUB.S		(A1),FP0	...FP0 IS R = (X-Y1)-Y2
	CMPI.L		#0,D0		...D0 < 0 IFF N IS ODD
	BGE.W		NEVEN

NODD:
*--REGISTERS SAVED SO FAR: D0, A0, FP2.

	FMOVE.X		FP0,RPRIME
	FMUL.X		FP0,FP0	 ...FP0 IS S = R*R
	FMOVE.D		SINA7,FP1	...A7
	FMOVE.D		COSB8,FP2	...B8
	FMUL.X		FP0,FP1	 ...SA7
	MOVE.L		d2,-(A7)
	MOVE.L		D0,d2
	FMUL.X		FP0,FP2	 ...SB8
	ROR.L		#1,d2
	ANDI.L		#$80000000,d2

	FADD.D		SINA6,FP1	...A6+SA7
	EOR.L		D0,d2
	ANDI.L		#$80000000,d2
	FADD.D		COSB7,FP2	...B7+SB8

	FMUL.X		FP0,FP1	 ...S(A6+SA7)
	EOR.L		d2,RPRIME
	MOVE.L		(A7)+,d2
	FMUL.X		FP0,FP2	 ...S(B7+SB8)
	ROR.L		#1,D0
	ANDI.L		#$80000000,D0

	FADD.D		SINA5,FP1	...A5+S(A6+SA7)
	MOVE.L		#$3F800000,POSNEG1
	EOR.L		D0,POSNEG1
	FADD.D		COSB6,FP2	...B6+S(B7+SB8)

	FMUL.X		FP0,FP1	 ...S(A5+S(A6+SA7))
	FMUL.X		FP0,FP2	 ...S(B6+S(B7+SB8))
	FMOVE.X		FP0,SPRIME

	FADD.D		SINA4,FP1	...A4+S(A5+S(A6+SA7))
	EOR.L		D0,SPRIME
	FADD.D		COSB5,FP2	...B5+S(B6+S(B7+SB8))

	FMUL.X		FP0,FP1	 ...S(A4+...)
	FMUL.X		FP0,FP2	 ...S(B5+...)

	FADD.D		SINA3,FP1	...A3+S(A4+...)
	FADD.D		COSB4,FP2	...B4+S(B5+...)

	FMUL.X		FP0,FP1	 ...S(A3+...)
	FMUL.X		FP0,FP2	 ...S(B4+...)

	FADD.X		SINA2,FP1	...A2+S(A3+...)
	FADD.X		COSB3,FP2	...B3+S(B4+...)

	FMUL.X		FP0,FP1	 ...S(A2+...)
	FMUL.X		FP0,FP2	 ...S(B3+...)

	FADD.X		SINA1,FP1	...A1+S(A2+...)
	FADD.X		COSB2,FP2	...B2+S(B3+...)

	FMUL.X		FP0,FP1	 ...S(A1+...)
	FMUL.X		FP2,FP0	 ...S(B2+...)
	fmovem.x	(a7)+,fp2	...fp2 restored

	FMUL.X		RPRIME,FP1	...R'S(A1+...)
	FADD.S		COSB1,FP0	...B1+S(B2...)
	FMUL.X		SPRIME,FP0	...S'(B1+S(B2+...))

	FMOVE.L		d1,FPCR		;restore users exceptions
	FADD.X		RPRIME,FP1	...COS(X)
	bsr		sto_cos		;store cosine result
	FADD.S		POSNEG1,FP0	...SIN(X)

	bra		t_frcinx


NEVEN:
*--REGISTERS SAVED SO FAR: d2, FP2.

	FMOVE.X		FP0,RPRIME
	FMUL.X		FP0,FP0	 ...FP0 IS S = R*R
	FMOVE.D		COSB8,FP1			...B8
	FMOVE.D		SINA7,FP2			...A7
	FMUL.X		FP0,FP1	 ...SB8
	FMOVE.X		FP0,SPRIME
	FMUL.X		FP0,FP2	 ...SA7
	ROR.L		#1,D0
	ANDI.L		#$80000000,D0
	FADD.D		COSB7,FP1	...B7+SB8
	FADD.D		SINA6,FP2	...A6+SA7
	EOR.L		D0,RPRIME
	EOR.L		D0,SPRIME
	FMUL.X		FP0,FP1	 ...S(B7+SB8)
	ORI.L		#$3F800000,D0
	MOVE.L		D0,POSNEG1
	FMUL.X		FP0,FP2	 ...S(A6+SA7)

	FADD.D		COSB6,FP1	...B6+S(B7+SB8)
	FADD.D		SINA5,FP2	...A5+S(A6+SA7)

	FMUL.X		FP0,FP1	 ...S(B6+S(B7+SB8))
	FMUL.X		FP0,FP2	 ...S(A5+S(A6+SA7))

	FADD.D		COSB5,FP1	...B5+S(B6+S(B7+SB8))
	FADD.D		SINA4,FP2	...A4+S(A5+S(A6+SA7))

	FMUL.X		FP0,FP1	 ...S(B5+...)
	FMUL.X		FP0,FP2	 ...S(A4+...)

	FADD.D		COSB4,FP1	...B4+S(B5+...)
	FADD.D		SINA3,FP2	...A3+S(A4+...)

	FMUL.X		FP0,FP1	 ...S(B4+...)
	FMUL.X		FP0,FP2	 ...S(A3+...)

	FADD.X		COSB3,FP1	...B3+S(B4+...)
	FADD.X		SINA2,FP2	...A2+S(A3+...)

	FMUL.X		FP0,FP1	 ...S(B3+...)
	FMUL.X		FP0,FP2	 ...S(A2+...)

	FADD.X		COSB2,FP1	...B2+S(B3+...)
	FADD.X		SINA1,FP2	...A1+S(A2+...)

	FMUL.X		FP0,FP1	 ...S(B2+...)
	fmul.x		fp2,fp0	 ...s(a1+...)
	fmovem.x	(a7)+,fp2	...fp2 restored
	FADD.S		COSB1,FP1	...B1+S(B2...)
	FMUL.X		RPRIME,FP0	...R'S(A1+...)
	FMUL.X		SPRIME,FP1	...S'(B1+S(B2+...))

	FMOVE.L		d1,FPCR		;restore users exceptions
	FADD.S		POSNEG1,FP1	...COS(X)
	bsr		sto_cos		;store cosine result
	FADD.X		RPRIME,FP0	...SIN(X)

	bra		t_frcinx

SCBORS:
	CMPI.L		#$3FFF8000,D0
	BGT.W		REDUCEX
SCSM:
	MOVE.W		#$0000,XDCARE
	FMOVE.S		#:3F800000,FP1

	FMOVE.L		d1,FPCR		;restore users exceptions
	FSUB.S		#:00800000,FP1
	bsr		sto_cos		;store cosine result
	FMOVE.X		X,FP0
	bra		t_frcinx

	end

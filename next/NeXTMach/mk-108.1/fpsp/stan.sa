*
*	stan.sa 1.4 10/1/90
*
*	The entry point stan computes the tangent of
*	an input argument;
*	stand does the same except for denormalized input.
*
*	Input: Double-extended number X in location pointed to
*		by address register a0.
*
*	Output: The value tan(X) returned in floating-point register Fp0.
*
*	Accuracy and Monotonicity: The returned result is within 3 ulp in
*		64 significant bit, i.e. within 0.5001 ulp to 53 bits if the
*		result is subsequently rounded to double precision. The
*		result is provably monotonic in double precision.
*
*	Speed: The program sTAN takes approximately 170 cycles for
*		input argument X such that |X| < 15Pi, which is the the usual
*		situation.
*
*	Algorithm:
*
*	1. If |X| >= 15Pi or |X| < 2**(-40), go to 6.
*
*	2. Decompose X as X = N(Pi/2) + r where |r| <= Pi/4. Let
*		k = N mod 2, so in particular, k = 0 or 1.
*
*	3. If k is odd, go to 5.
*
*	4. (k is even) Tan(X) = tan(r) and tan(r) is approximated by a
*		rational function U/V where
*		U = r + r*s*(P1 + s*(P2 + s*P3)), and
*		V = 1 + s*(Q1 + s*(Q2 + s*(Q3 + s*Q4))),  s = r*r.
*		Exit.
*
*	4. (k is odd) Tan(X) = -cot(r). Since tan(r) is approximated by a
*		rational function U/V where
*		U = r + r*s*(P1 + s*(P2 + s*P3)), and
*		V = 1 + s*(Q1 + s*(Q2 + s*(Q3 + s*Q4))), s = r*r,
*		-Cot(r) = -V/U. Exit.
*
*	6. If |X| > 1, go to 8.
*
*	7. (|X|<2**(-40)) Tan(X) = X. Exit.
*
*	8. Overwrite X by X := X rem 2Pi. Now that |X| <= Pi, go back to 2.
*

*		Copyright (C) Motorola, Inc. 1990
*			All Rights Reserved
*
*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MOTOROLA 
*	The copyright notice above does not evidence any  
*	actual or intended publication of such source code.

STAN	IDNT	2,1 Motorola 040 Floating Point Software Package

	section	15

N	DC.L $00000000

BOUNDS1	DC.L $3FD78000,$4004BC7E
TWOBYPI	DC.L $3FE45F30,$6DC9C883

TANQ4	DC.L $3EA0B759,$F50F8688
TANP3	DC.L $BEF2BAA5,$A8924F04

TANQ3	DC.L $BF346F59,$B39BA65F,$00000000,$00000000

TANP2	DC.L $3FF60000,$E073D3FC,$199C4A00,$00000000

TANQ2	DC.L $3FF90000,$D23CD684,$15D95FA1,$00000000

TANP1	DC.L $BFFC0000,$8895A6C5,$FB423BCA,$00000000

TANQ1	DC.L $BFFD0000,$EEF57E0D,$A84BC8CE,$00000000

INARG	DC.L $00000000,$00000000,$00000000
ENDFLAG	DC.L $00000000

INVTWOPI DC.L $3FFC0000,$A2F9836E,$4E44152A
TWOTO63	DC.L $5F000000

TWOPI1	DC.L $40010000,$C90FDAA2,$00000000,$00000000
TWOPI2	DC.L $3FDF0000,$85A308D4,$00000000,$00000000

*--N*PI/2, -32 <= N <= 32, IN A LEADING TERM IN EXT. AND TRAILING
*--TERM IN SGL. NOTE THAT PI IS 64-BIT LONG, THUS N*PI/2 IS AT
*--MOST 69 BITS LONG.
NPIBY2
	DC.L	$C0040000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0040000,$C2C75BCD,$105D7C23,$A1B00000
	DC.L	$C0040000,$BC7EDCF7,$FF523612,$21A00000
	DC.L	$C0040000,$B6365E22,$EE46F000,$A0000000
	DC.L	$C0040000,$AFEDDF4D,$DD3BA9EE,$A1C00000
	DC.L	$C0040000,$A9A56078,$CC3063DD,$21900000
	DC.L	$C0040000,$A35CE1A3,$BB251DCB,$A0800000
	DC.L	$C0040000,$9D1462CE,$AA19D7B9,$A1D00000
	DC.L	$C0040000,$96CBE3F9,$990E91A8,$21800000
	DC.L	$C0040000,$90836524,$88034B96,$A0C00000
	DC.L	$C0040000,$8A3AE64F,$76F80584,$A1E00000
	DC.L	$C0040000,$83F2677A,$65ECBF73,$21600000
	DC.L	$C0030000,$FB53D14A,$A9C2F2C2,$A1000000
	DC.L	$C0030000,$EEC2D3A0,$87AC669F,$20000000
	DC.L	$C0030000,$E231D5F6,$6595DA7C,$21400000
	DC.L	$C0030000,$D5A0D84C,$437F4E58,$A1200000
	DC.L	$C0030000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0030000,$BC7EDCF7,$FF523612,$21200000
	DC.L	$C0030000,$AFEDDF4D,$DD3BA9EE,$A1400000
	DC.L	$C0030000,$A35CE1A3,$BB251DCB,$A0000000
	DC.L	$C0030000,$96CBE3F9,$990E91A8,$21000000
	DC.L	$C0030000,$8A3AE64F,$76F80584,$A1600000
	DC.L	$C0020000,$FB53D14A,$A9C2F2C2,$A0800000
	DC.L	$C0020000,$E231D5F6,$6595DA7C,$20C00000
	DC.L	$C0020000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0020000,$AFEDDF4D,$DD3BA9EE,$A0C00000
	DC.L	$C0020000,$96CBE3F9,$990E91A8,$20800000
	DC.L	$C0010000,$FB53D14A,$A9C2F2C2,$A0000000
	DC.L	$C0010000,$C90FDAA2,$2168C235,$00000000
	DC.L	$C0010000,$96CBE3F9,$990E91A8,$20000000
	DC.L	$C0000000,$C90FDAA2,$2168C235,$00000000
	DC.L	$BFFF0000,$C90FDAA2,$2168C235,$00000000
	DC.L	$00000000,$00000000,$00000000,$00000000
	DC.L	$3FFF0000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40000000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40010000,$96CBE3F9,$990E91A8,$A0000000
	DC.L	$40010000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40010000,$FB53D14A,$A9C2F2C2,$20000000
	DC.L	$40020000,$96CBE3F9,$990E91A8,$A0800000
	DC.L	$40020000,$AFEDDF4D,$DD3BA9EE,$20C00000
	DC.L	$40020000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40020000,$E231D5F6,$6595DA7C,$A0C00000
	DC.L	$40020000,$FB53D14A,$A9C2F2C2,$20800000
	DC.L	$40030000,$8A3AE64F,$76F80584,$21600000
	DC.L	$40030000,$96CBE3F9,$990E91A8,$A1000000
	DC.L	$40030000,$A35CE1A3,$BB251DCB,$20000000
	DC.L	$40030000,$AFEDDF4D,$DD3BA9EE,$21400000
	DC.L	$40030000,$BC7EDCF7,$FF523612,$A1200000
	DC.L	$40030000,$C90FDAA2,$2168C235,$00000000
	DC.L	$40030000,$D5A0D84C,$437F4E58,$21200000
	DC.L	$40030000,$E231D5F6,$6595DA7C,$A1400000
	DC.L	$40030000,$EEC2D3A0,$87AC669F,$A0000000
	DC.L	$40030000,$FB53D14A,$A9C2F2C2,$21000000
	DC.L	$40040000,$83F2677A,$65ECBF73,$A1600000
	DC.L	$40040000,$8A3AE64F,$76F80584,$21E00000
	DC.L	$40040000,$90836524,$88034B96,$20C00000
	DC.L	$40040000,$96CBE3F9,$990E91A8,$A1800000
	DC.L	$40040000,$9D1462CE,$AA19D7B9,$21D00000
	DC.L	$40040000,$A35CE1A3,$BB251DCB,$20800000
	DC.L	$40040000,$A9A56078,$CC3063DD,$A1900000
	DC.L	$40040000,$AFEDDF4D,$DD3BA9EE,$21C00000
	DC.L	$40040000,$B6365E22,$EE46F000,$20000000
	DC.L	$40040000,$BC7EDCF7,$FF523612,$A1A00000
	DC.L	$40040000,$C2C75BCD,$105D7C23,$21B00000
	DC.L	$40040000,$C90FDAA2,$2168C235,$00000000

	section	8

	xref	t_frcinx
	xref	t_extdnrm

	xdef	stand
stand:
*--TAN(X) = X FOR DENORMALIZED X

	bra		t_extdnrm

	xdef	stan
stan:
	FMOVE.L		fpcr,d1
	FMOVE.L		#0,fpcr

	FMOVE.X		(a0),FP0	...LOAD INPUT

	move.l		(a0),d0
	move.w		4(a0),d0
	ANDI.L		#$7FFFFFFF,D0
	CMP2.L		BOUNDS1,D0	...2**(-40) < |X| < 15 PI?
	BCS.W		TANBORS

TANMAIN:
*--THIS IS THE USUAL CASE, |X| <= 15 PI.
*--THE ARGUMENT REDUCTION IS DONE BY TABLE LOOK UP.
	FMOVE.X		FP0,FP1
	FMUL.D		TWOBYPI,FP1	...X*2/PI

*--HIDE THE NEXT TWO INSTRUCTIONS
	lea.l		NPIBY2+$200,a1 ...TABLE OF N*PI/2, N = -32,...,32
	fmovem.x	fp2,-(sp)	...save fp2

*--FP1 IS NOW READY
	FMOVE.L		FP1,N		...CONVERT TO INTEGER

	MOVE.L		N,D0
	ASL.L		#4,D0
	ADDA.L		D0,a1		...ADDRESS N*PIBY2 IN Y1, Y2

	FSUB.X		(a1)+,FP0	...X-Y1
*--HIDE THE NEXT ONE
	fmovem.x	fp3,-(sp)	...save fp3
	FSUB.S		(a1),FP0	...FP0 IS R = (X-Y1)-Y2
	ROR.L		#5,D0
	ANDI.L		#$80000000,D0	...D0 WAS ODD IFF D0 < 0
	CMPI.L		#0,D0
	BLT.W		NODD

	FMOVE.X		FP0,FP1
	FMUL.X		FP1,FP1	 	...S = R*R

	FMOVE.D		TANQ4,FP3
	FMOVE.D		TANP3,FP2

	FMUL.X		FP1,FP3	 	...SQ4
	FMUL.X		FP1,FP2	 	...SP3

	FADD.D		TANQ3,FP3	...Q3+SQ4
	FADD.X		TANP2,FP2	...P2+SP3

	FMUL.X		FP1,FP3	 	...S(Q3+SQ4)
	FMUL.X		FP1,FP2	 	...S(P2+SP3)

	FADD.X		TANQ2,FP3	...Q2+S(Q3+SQ4)
	FADD.X		TANP1,FP2	...P1+S(P2+SP3)

	FMUL.X		FP1,FP3	 	...S(Q2+S(Q3+SQ4))
	FMUL.X		FP1,FP2	 	...S(P1+S(P2+SP3))

	FADD.X		TANQ1,FP3	...Q1+S(Q2+S(Q3+SQ4))
	FMUL.X		FP0,FP2	 	...RS(P1+S(P2+SP3))

	FMUL.X		FP3,FP1	 	...S(Q1+S(Q2+S(Q3+SQ4)))
	fmovem.x	(sp)+,fp3	...fp3 restored

	FADD.X		FP2,FP0	 	...R+RS(P1+S(P2+SP3))
	fmovem.x	(sp)+,fp2	...fp2 restored

	FADD.S		#:3F800000,FP1	...1+S(Q1+...)

	FMOVE.L		d1,fpcr		;restore users exceptions
	FDIV.X		FP1,FP0		;last inst - possible exception set

	bra		t_frcinx

NODD:
	FMOVE.X		FP0,FP1
	FMUL.X		FP0,FP0	 	...S = R*R

	FMOVE.D		TANQ4,FP3
	FMOVE.D		TANP3,FP2

	FMUL.X		FP0,FP3	 	...SQ4
	FMUL.X		FP0,FP2	 	...SP3

	FADD.D		TANQ3,FP3	...Q3+SQ4
	FADD.X		TANP2,FP2	...P2+SP3

	FMUL.X		FP0,FP3	 	...S(Q3+SQ4)
	FMUL.X		FP0,FP2	 	...S(P2+SP3)

	FADD.X		TANQ2,FP3	...Q2+S(Q3+SQ4)
	FADD.X		TANP1,FP2	...P1+S(P2+SP3)

	FMUL.X		FP0,FP3	 	...S(Q2+S(Q3+SQ4))
	FMUL.X		FP0,FP2	 	...S(P1+S(P2+SP3))

	FADD.X		TANQ1,FP3	...Q1+S(Q2+S(Q3+SQ4))
	FMUL.X		FP1,FP2	 	...RS(P1+S(P2+SP3))

	FMUL.X		FP3,FP0	 	...S(Q1+S(Q2+S(Q3+SQ4)))
	fmovem.x	(sp)+,fp3	...fp3 restored

	FADD.X		FP2,FP1	 	...R+RS(P1+S(P2+SP3))
	FADD.S		#:3F800000,FP0	...1+S(Q1+...)
	fmovem.x	(sp)+,fp2	...fp2 restored

	FMOVE.X		FP1,-(sp)
	EORI.L		#$80000000,(sp)

	FMOVE.L		d1,fpcr	 	;restore users exceptions
	FDIV.X		(sp)+,FP0	;last inst - possible exception set

	bra		t_frcinx

TANBORS:
*--IF |X| > 15PI, WE USE THE GENERAL ARGUMENT REDUCTION.
*--IF |X| < 2**(-40), RETURN X OR 1.
	CMPI.L		#$3FFF8000,D0
	BGT.B		REDUCEX

	FMOVE.X		FP0,-(sp)
	FMOVE.L		d1,fpcr		 ;restore users exceptions
	FMOVE.X		(sp)+,FP0	;last inst - posibble exception set

	bra		t_frcinx

REDUCEX:
*--WHEN REDUCEX IS USED, THE CODE WILL INEVITABLY BE SLOW.
*--THIS REDUCTION METHOD, HOWEVER, IS MUCH FASTER THAN USING
*--THE REMAINDER INSTRUCTION WHICH IS NOW IN SOFTWARE.

	fmovem.x	fp2,-(sp)
	MOVE.L		D2,-(sp)
*--ON ENTRY, FP0 IS X, ON RETURN, FP0 IS X REM 2PI, |X| <= PI.

LOOP:
	FMOVE.X		FP0,INARG	...+-2**K * F, 1 <= F < 2
	MOVE.W		INARG,D0
	ANDI.L		#$00007FFF,D0
	SUBI.L		#$00003FFF,D0	...D0 IS K
	CMPI.L		#28,D0
	BLE.B		LASTLOOP

	SUBI.L		#28,D0	 ...D0 IS L := K-28
	MOVE.L		#0,ENDFLAG
	BRA.B		WORK
LASTLOOP:
	CLR.L		D0		...D0 IS L := 0
	MOVE.L		#1,ENDFLAG

WORK:
*--FIND THE REMAINDER OF X W.R.T.	2**L * 2PI. L IS SO CHOSEN
*--THAT	INT( X * 2PI / 2**(L) ) < 2**30.

*--CREATE 2**(-L) * INVTWOPI, SIGN(INARG)*2**(63),
*--2**L * TWOPI1, 2**L * TWOPI2

	MOVE.L		#$00003FFC,d2	...BIASED EXPO INVTWOPI
	SUB.L		D0,d2		...BIASED EXPO 2**(-L)*INVTWOPI
	MOVE.W		d2,INVTWOPI
	FMOVE.X		FP0,FP1
	FMUL.X		INVTWOPI,FP1
*--WE MUST NOW FIND INT(FP1). SINCE WE NEED THIS VALUE IN
*--FLOATING POINT FORMAT, THE TWO FMOVE'S	FMOVE.L FP <--> N
*--WILL BE TOO INEFFICIENT. THE WAY AROUND IT IS THAT
*--(SIGN(INARG)*2**63	+	FP1) - SIGN(INARG)*2**63 WILL GIVE
*--US THE DESIRED VALUE IN FLOATING POINT.

*--HIDE SIX CYCLES OF INSTRUCTION
	MOVE.L		INARG,d2
	ANDI.L		#$80000000,d2
	ORI.L		#$5F000000,d2	...d2 IS SIGN(INARG)*2**63 IN SGL
	MOVE.L		d2,TWOTO63

	MOVE.L		D0,d2
	ADDI.L		#$00004001,d2	...BIASED EXPO OF 2**L * TWOPI

*--FP1 IS READY
	FADD.S		TWOTO63,FP1	...FRACT. PART OF FP1 IS ROUNDED

*--HIDE 4 CYCLES OF INSTRUCTION
	MOVE.W		d2,TWOPI1
	ADDI.L		#$00003FDF,D0
	MOVE.W		D0,TWOPI2
	MOVE.L		ENDFLAG,D0

*--FP1 IS READY
	FSUB.S		TWOTO63,FP1
*--HIDE THE NEXT INSTRUCTION
	FMOVE.X		TWOPI1,FP2
	FMUL.X		FP1,FP2	...M*Y1
	FMUL.X		TWOPI2,FP1	...M*Y2
	FSUB.X		FP2,FP0	...(X-MY1)
	FSUB.X		FP1,FP0	...(X-MY1)-MY2
*--FP0 IS X REM 2**L * 2PI
	CMPI.L		#0,D0
	BLE.W		LOOP

	MOVE.L		(sp)+,d2
	FMOVE.X		(sp)+,FP2

	BRA.W		TANMAIN

	end
